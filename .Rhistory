phylo.out = sim.results$phylo.out
params.out = sim.results$params.out
if (sim.matrix$reg.of.origin[sim.matrix$sim.id == sim] == 'tropical' ) { extreme.bin = trop.orig.extreme };
if (sim.matrix$reg.of.origin[sim.matrix$sim.id == sim] == 'temperate' ) { extreme.bin = temp.orig.extreme };
#if (time.richness$spp.rich[time.richness$time == pre.equil.time & time.richness$region == extreme.bin] > 5) {
max.time.actual = max(time.richness$time);
# If just a single timeslice, then use the end of the simulation or a designated time, otherwise space them equally
if (num.of.time.slices==1) {
timeslices = pre.equil.time
} else {
if ( num.of.time.slices == -999  ) {
timeslices = which.time.slices
} else {
timeslices = as.integer(round(seq(max(time.richness$time)/num.of.time.slices,max(time.richness$time),length=num.of.time.slices),digits=0));
}
}
skipped.clades = 0
skipped.times = ""
max.time.actual = max(time.richness$time);
# If just a single timeslice, then use the end of the simulation or a designated time, otherwise space them equally
if (num.of.time.slices == 1) { timeslices = pre.equil.time};
if (which.time.slices != -999  ) { timeslices = which.time.slices };
if (num.of.time.slices > 1) {timeslices = as.integer(round(seq(max(time.richness$time)/num.of.time.slices,max(time.richness$time),length=num.of.time.slices),digits=0))};
if (time.sequence[1] != -999) {timeslices = subset(time.sequence,time.sequence <= max(time.richness$time))};
skipped.clades = 0
skipped.times = ""
timeslices
time.sequence = seq(1000,100000,length=100);
if (num.of.time.slices == 1) { timeslices = pre.equil.time};
if (which.time.slices != -999  ) { timeslices = which.time.slices };
if (num.of.time.slices > 1) {timeslices = as.integer(round(seq(max(time.richness$time)/num.of.time.slices,max(time.richness$time),length=num.of.time.slices),digits=0))};
if (time.sequence[1] != -999) {timeslices = subset(time.sequence,time.sequence <= max(time.richness$time))};
skipped.clades = 0
skipped.times = ""
timeslices
time.sequence = seq(2,300,length=100);
max.time.actual = max(time.richness$time);
# If just a single timeslice, then use the end of the simulation or a designated time, otherwise space them equally
if (num.of.time.slices == 1) { timeslices = pre.equil.time};
if (which.time.slices != -999  ) { timeslices = which.time.slices };
if (num.of.time.slices > 1) {timeslices = as.integer(round(seq(max(time.richness$time)/num.of.time.slices,max(time.richness$time),length=num.of.time.slices),digits=0))};
if (time.sequence[1] != -999) {timeslices = subset(time.sequence,time.sequence <= max(time.richness$time))};
timeslices
time.sequence = seq(2,300,length=100);
time.sequence
time.sequence = round(seq(2,300,length=100),digits=0);
time.sequence
max.time.actual = max(time.richness$time);
# If just a single timeslice, then use the end of the simulation or a designated time, otherwise space them equally
if (num.of.time.slices == 1) { timeslices = pre.equil.time};
if (which.time.slices != -999  ) { timeslices = which.time.slices };
if (num.of.time.slices > 1) {timeslices = as.integer(round(seq(max(time.richness$time)/num.of.time.slices,max(time.richness$time),length=num.of.time.slices),digits=0))};
if (time.sequence[1] != -999) {timeslices = subset(time.sequence,time.sequence <= max(time.richness$time))};
timeslices
for (t in timeslices) {
# vector of species in existence at time t
sub.species = as.character(unique(subset(all.populations,time.of.sp.origin <= t & time.of.sp.extinction > t, select = 'spp.name'))[,1]);
# Some species may be extant globally (extant==1) but in our boundary regions (0,11) only;
# we need to eliminate species that are not extant within regions 1-10 (which is all that is
# reflected in the all.populations dataframe)
time.slice.populations = all.populations;
time.slice.populations$extant = 0;
time.slice.populations$extant[time.slice.populations$time.of.origin <= t & time.slice.populations$time.of.extinction > t] = 1
extant.ornot = aggregate(time.slice.populations$extant,by=list(time.slice.populations$spp.name),sum)
extinct.species = as.character(extant.ornot[extant.ornot$x==0,'Group.1'])
# FIXME:
# Add more explanatory comments justifying why we don't need to consider species that existed
# at time t but went extinct before the present.
# In some cases (e.g. sim 1 or 2, t=6000), tips.to.drop includes all tips and so sub.phylo is empty.
# Does it make sense for this to ever happen? If not, fix it.
# If so, need to provide an if-else error catch both in the creation of sub.phylo,
# and of sub.clade.phylo inside the clade loop. (Sim 3, t = 156 bonks at that point)
# NOTE: code runs for sim==5 currently as a test case
sub.species2 = sub.species[!sub.species %in% extinct.species]
tips.to.drop = as.character(phylo.out$tip.label[!phylo.out$tip.label %in% sub.species2]);
# check to see if there are at least min.num.spp species for continuing with the analysis; if not store the skipped timeslice
if ( (length(phylo.out$tip.label) - length(tips.to.drop)) < min.num.spp) {
skipped.times = paste(skipped.times, t) # keep track of the timeslices that were skipped in a text string
} else {
sub.phylo = drop.tip(phylo.out,tips.to.drop);
temp.root.time = max(dist.nodes(sub.phylo)[1:Ntip(sub.phylo),Ntip(sub.phylo) + 1]); temp.root.time;
most.recent.spp = sub.phylo$tip.label[as.numeric(names(which.max(dist.nodes(sub.phylo)[1:Ntip(sub.phylo),Ntip(sub.phylo) + 1])))]; most.recent.spp;
extinct.time.most.recent = unique(all.populations$time.of.sp.extinction[all.populations$spp.name==most.recent.spp]); extinct.time.most.recent;
sub.phylo$root.time = temp.root.time + max(c(0,max.time.actual - extinct.time.most.recent)); sub.phylo$root.time;
sub.phylo = collapse.singles(timeSliceTree(sub.phylo,sliceTime=(max.time.actual - t),plot=F,drop.extinct = T));
num.of.spp = length(sub.phylo$tip.label);
if (root.only == 1) { sub.clade.loop.end = (num.of.spp+1) }
if (root.only == 0) { sub.clade.loop.end = max(sub.phylo$edge) }
for (c in (num.of.spp+1):sub.clade.loop.end) {
#pull out list of species names belonging to each subclade
sub.clade = clade.members(c, sub.phylo, tip.labels=T)
subset.populations = subset(all.populations, spp.name %in% as.numeric(sub.clade));
#sub.populations is the subset of populations specific to a particular clade and timeslice
sub.populations = subset(subset.populations, time.of.origin <= t & time.of.extinction > t)
#sub.clade.phylo is a specific simulation clade pulled from the phylogeny that was sliced at timeslice t
tips.to.drop2 = as.character(sub.phylo$tip.label[which(is.element(sub.phylo$tip.label,as.character(sub.populations$spp.name))==F)]);
# check to see if there are at least min.num.spp species for continuing with the analysis; if not increment skipped.clades
if((length(sub.phylo$tip.label) - length(tips.to.drop2)) < min.num.spp) {
skipped.clades = skipped.clades + 1
} else {
sub.clade.phylo = drop.tip(sub.phylo,tips.to.drop2);
sub.clade.phylo$root.time = max(dist.nodes(sub.clade.phylo)[1:Ntip(sub.clade.phylo),Ntip(sub.clade.phylo) + 1]); sub.clade.phylo$root.time;
sub.clade.phylo$origin.time = t - sub.clade.phylo$root.time; sub.clade.phylo$origin.time;
if (identical(sort(as.integer(unique(sub.populations$spp.name))) , sort(as.integer(sub.clade.phylo$tip.label)))==F ) {print(c(c,t,'Error: trimmed phylogeny does not contain the correct species')); break} else{};
reg.summary = regional.calc(sub.populations[,c('region','spp.name','time.of.origin','reg.env','extant')], sub.clade.phylo, as.integer(t));
#Note that extinction calculation must be done on subset.populations, not sub.populations
extinction = extinct.calc(subset.populations, timeslice=t)
reg.summary2 = merge(reg.summary,extinction[,c('region','extinction.rate')],by='region')
MRD.range = max(reg.summary$MRD,na.rm = T) - min(reg.summary$MRD,na.rm = T)
MRD.mean = mean(reg.summary$MRD,na.rm = T)
MRD.var = var(reg.summary$MRD,na.rm = T)
MRD.rich.slope = summary(lm(reg.summary$MRD ~ reg.summary$richness))$coef[2,1]
MRD.env.slope = summary(lm(reg.summary$MRD ~ reg.summary$reg.env))$coef[2,1]
PSV.range = max(reg.summary$PSV,na.rm = T) - min(reg.summary$PSV,na.rm = T)
PSV.mean = mean(reg.summary$PSV,na.rm = T)
PSV.var = var(reg.summary$PSV,na.rm = T)
PSV.rich.slope = summary(lm(reg.summary$PSV ~ reg.summary$richness))$coef[2,1]
PSV.env.slope = summary(lm(reg.summary$PSV ~ reg.summary$reg.env))$coef[2,1]
n.div.regions = length(reg.summary$region[reg.summary$richness > 1])
corr.results = cbind(xregion.analysis(reg.summary2),MRD.range,MRD.mean,MRD.var,MRD.rich.slope,MRD.env.slope,
PSV.range,PSV.mean,PSV.var,PSV.rich.slope,PSV.env.slope,n.div.regions)
#Pybus & Harvey (2000)'s gamma statistic
Gamma.stat = gammaStat(sub.clade.phylo)
#Calculate Blomberg's K for two traits: environmental optimum, and mean region of occurrence
spp.traits = aggregate(sub.populations$region, by = list(sub.populations$spp.name, sub.populations$env.opt),
function(x) mean(x, na.rm=T))
names(spp.traits) = c('spp.name','env.opt','region')
spp.env = spp.traits$env.opt
names(spp.env) = spp.traits$spp.name
BK.env = phylosig(sub.clade.phylo, spp.env[sub.clade.phylo$tip.label], method="K")
spp.reg = spp.traits$region
names(spp.reg) = spp.traits$spp.name
BK.reg = phylosig(sub.clade.phylo, spp.reg[sub.clade.phylo$tip.label], method="K")
output = rbind(output, cbind(sim=sim,clade.id = c, time = t, corr.results, gamma.stat = Gamma.stat,
clade.richness = length(unique(sub.populations$spp.name)),
BK.env = BK.env , BK.reg = BK.reg))
print(paste(sim,sub.clade.loop.end,c,t,date(),length(sub.clade.phylo$tip.label),sep="   "));
} # end third else
} # end sub clade for loop
} # end second else
}; # end timeslice loop
sim
t
time.sequence = round(seq(2,300,by=2),digits=0);
time.sequence = round(seq(2,300,by=2),digits=0); # for time scenario sims
output = numeric();
skipped.clades = 0
skipped.times = ""
for (t in timeslices) {
# vector of species in existence at time t
sub.species = as.character(unique(subset(all.populations,time.of.sp.origin <= t & time.of.sp.extinction > t, select = 'spp.name'))[,1]);
# Some species may be extant globally (extant==1) but in our boundary regions (0,11) only;
# we need to eliminate species that are not extant within regions 1-10 (which is all that is
# reflected in the all.populations dataframe)
time.slice.populations = all.populations;
time.slice.populations$extant = 0;
time.slice.populations$extant[time.slice.populations$time.of.origin <= t & time.slice.populations$time.of.extinction > t] = 1
extant.ornot = aggregate(time.slice.populations$extant,by=list(time.slice.populations$spp.name),sum)
extinct.species = as.character(extant.ornot[extant.ornot$x==0,'Group.1'])
# FIXME:
# Add more explanatory comments justifying why we don't need to consider species that existed
# at time t but went extinct before the present.
# In some cases (e.g. sim 1 or 2, t=6000), tips.to.drop includes all tips and so sub.phylo is empty.
# Does it make sense for this to ever happen? If not, fix it.
# If so, need to provide an if-else error catch both in the creation of sub.phylo,
# and of sub.clade.phylo inside the clade loop. (Sim 3, t = 156 bonks at that point)
# NOTE: code runs for sim==5 currently as a test case
sub.species2 = sub.species[!sub.species %in% extinct.species]
tips.to.drop = as.character(phylo.out$tip.label[!phylo.out$tip.label %in% sub.species2]);
# check to see if there are at least min.num.spp species for continuing with the analysis; if not store the skipped timeslice
if ( (length(phylo.out$tip.label) - length(tips.to.drop)) < min.num.spp) {
skipped.times = paste(skipped.times, t) # keep track of the timeslices that were skipped in a text string
} else {
sub.phylo = drop.tip(phylo.out,tips.to.drop);
temp.root.time = max(dist.nodes(sub.phylo)[1:Ntip(sub.phylo),Ntip(sub.phylo) + 1]); temp.root.time;
most.recent.spp = sub.phylo$tip.label[as.numeric(names(which.max(dist.nodes(sub.phylo)[1:Ntip(sub.phylo),Ntip(sub.phylo) + 1])))]; most.recent.spp;
extinct.time.most.recent = unique(all.populations$time.of.sp.extinction[all.populations$spp.name==most.recent.spp]); extinct.time.most.recent;
sub.phylo$root.time = temp.root.time + max(c(0,max.time.actual - extinct.time.most.recent)); sub.phylo$root.time;
sub.phylo = collapse.singles(timeSliceTree(sub.phylo,sliceTime=(max.time.actual - t),plot=F,drop.extinct = T));
num.of.spp = length(sub.phylo$tip.label);
if (root.only == 1) { sub.clade.loop.end = (num.of.spp+1) }
if (root.only == 0) { sub.clade.loop.end = max(sub.phylo$edge) }
for (c in (num.of.spp+1):sub.clade.loop.end) {
#pull out list of species names belonging to each subclade
sub.clade = clade.members(c, sub.phylo, tip.labels=T)
subset.populations = subset(all.populations, spp.name %in% as.numeric(sub.clade));
#sub.populations is the subset of populations specific to a particular clade and timeslice
sub.populations = subset(subset.populations, time.of.origin <= t & time.of.extinction > t)
#sub.clade.phylo is a specific simulation clade pulled from the phylogeny that was sliced at timeslice t
tips.to.drop2 = as.character(sub.phylo$tip.label[which(is.element(sub.phylo$tip.label,as.character(sub.populations$spp.name))==F)]);
# check to see if there are at least min.num.spp species for continuing with the analysis; if not increment skipped.clades
if((length(sub.phylo$tip.label) - length(tips.to.drop2)) < min.num.spp) {
skipped.clades = skipped.clades + 1
} else {
sub.clade.phylo = drop.tip(sub.phylo,tips.to.drop2);
sub.clade.phylo$root.time = max(dist.nodes(sub.clade.phylo)[1:Ntip(sub.clade.phylo),Ntip(sub.clade.phylo) + 1]); sub.clade.phylo$root.time;
sub.clade.phylo$origin.time = t - sub.clade.phylo$root.time; sub.clade.phylo$origin.time;
if (identical(sort(as.integer(unique(sub.populations$spp.name))) , sort(as.integer(sub.clade.phylo$tip.label)))==F ) {print(c(c,t,'Error: trimmed phylogeny does not contain the correct species')); break} else{};
reg.summary = regional.calc(sub.populations[,c('region','spp.name','time.of.origin','reg.env','extant')], sub.clade.phylo, as.integer(t));
#Note that extinction calculation must be done on subset.populations, not sub.populations
extinction = extinct.calc(subset.populations, timeslice=t)
reg.summary2 = merge(reg.summary,extinction[,c('region','extinction.rate')],by='region')
MRD.range = max(reg.summary$MRD,na.rm = T) - min(reg.summary$MRD,na.rm = T)
MRD.mean = mean(reg.summary$MRD,na.rm = T)
MRD.var = var(reg.summary$MRD,na.rm = T)
MRD.rich.slope = summary(lm(reg.summary$MRD ~ reg.summary$richness))$coef[2,1]
MRD.env.slope = summary(lm(reg.summary$MRD ~ reg.summary$reg.env))$coef[2,1]
PSV.range = max(reg.summary$PSV,na.rm = T) - min(reg.summary$PSV,na.rm = T)
PSV.mean = mean(reg.summary$PSV,na.rm = T)
PSV.var = var(reg.summary$PSV,na.rm = T)
PSV.rich.slope = summary(lm(reg.summary$PSV ~ reg.summary$richness))$coef[2,1]
PSV.env.slope = summary(lm(reg.summary$PSV ~ reg.summary$reg.env))$coef[2,1]
n.div.regions = length(reg.summary$region[reg.summary$richness > 1])
corr.results = cbind(xregion.analysis(reg.summary2),MRD.range,MRD.mean,MRD.var,MRD.rich.slope,MRD.env.slope,
PSV.range,PSV.mean,PSV.var,PSV.rich.slope,PSV.env.slope,n.div.regions)
#Pybus & Harvey (2000)'s gamma statistic
Gamma.stat = gammaStat(sub.clade.phylo)
#Calculate Blomberg's K for two traits: environmental optimum, and mean region of occurrence
spp.traits = aggregate(sub.populations$region, by = list(sub.populations$spp.name, sub.populations$env.opt),
function(x) mean(x, na.rm=T))
names(spp.traits) = c('spp.name','env.opt','region')
spp.env = spp.traits$env.opt
names(spp.env) = spp.traits$spp.name
BK.env = phylosig(sub.clade.phylo, spp.env[sub.clade.phylo$tip.label], method="K")
spp.reg = spp.traits$region
names(spp.reg) = spp.traits$spp.name
BK.reg = phylosig(sub.clade.phylo, spp.reg[sub.clade.phylo$tip.label], method="K")
output = rbind(output, cbind(sim=sim,clade.id = c, time = t, corr.results, gamma.stat = Gamma.stat,
clade.richness = length(unique(sub.populations$spp.name)),
BK.env = BK.env , BK.reg = BK.reg))
print(paste(sim,sub.clade.loop.end,c,t,date(),length(sub.clade.phylo$tip.label),sep="   "));
} # end third else
} # end sub clade for loop
} # end second else
}; # end timeslice loop
time.sequence = seq(2,300,by=2); # for time scenario sims
time.sequence
max.time.actual = max(time.richness$time);
# If just a single timeslice, then use the end of the simulation or a designated time, otherwise space them equally
if (num.of.time.slices == 1) { timeslices = pre.equil.time};
if (which.time.slices != -999  ) { timeslices = which.time.slices };
if (num.of.time.slices > 1) {timeslices = as.integer(round(seq(max(time.richness$time)/num.of.time.slices,max(time.richness$time),length=num.of.time.slices),digits=0))};
if (time.sequence[1] != -999) {timeslices = subset(time.sequence,time.sequence <= max(time.richness$time))};
skipped.clades = 0
skipped.times = ""
for (t in timeslices) {
# vector of species in existence at time t
sub.species = as.character(unique(subset(all.populations,time.of.sp.origin <= t & time.of.sp.extinction > t, select = 'spp.name'))[,1]);
# Some species may be extant globally (extant==1) but in our boundary regions (0,11) only;
# we need to eliminate species that are not extant within regions 1-10 (which is all that is
# reflected in the all.populations dataframe)
time.slice.populations = all.populations;
time.slice.populations$extant = 0;
time.slice.populations$extant[time.slice.populations$time.of.origin <= t & time.slice.populations$time.of.extinction > t] = 1
extant.ornot = aggregate(time.slice.populations$extant,by=list(time.slice.populations$spp.name),sum)
extinct.species = as.character(extant.ornot[extant.ornot$x==0,'Group.1'])
# FIXME:
# Add more explanatory comments justifying why we don't need to consider species that existed
# at time t but went extinct before the present.
# In some cases (e.g. sim 1 or 2, t=6000), tips.to.drop includes all tips and so sub.phylo is empty.
# Does it make sense for this to ever happen? If not, fix it.
# If so, need to provide an if-else error catch both in the creation of sub.phylo,
# and of sub.clade.phylo inside the clade loop. (Sim 3, t = 156 bonks at that point)
# NOTE: code runs for sim==5 currently as a test case
sub.species2 = sub.species[!sub.species %in% extinct.species]
tips.to.drop = as.character(phylo.out$tip.label[!phylo.out$tip.label %in% sub.species2]);
# check to see if there are at least min.num.spp species for continuing with the analysis; if not store the skipped timeslice
if ( (length(phylo.out$tip.label) - length(tips.to.drop)) < min.num.spp) {
skipped.times = paste(skipped.times, t) # keep track of the timeslices that were skipped in a text string
} else {
sub.phylo = drop.tip(phylo.out,tips.to.drop);
temp.root.time = max(dist.nodes(sub.phylo)[1:Ntip(sub.phylo),Ntip(sub.phylo) + 1]); temp.root.time;
most.recent.spp = sub.phylo$tip.label[as.numeric(names(which.max(dist.nodes(sub.phylo)[1:Ntip(sub.phylo),Ntip(sub.phylo) + 1])))]; most.recent.spp;
extinct.time.most.recent = unique(all.populations$time.of.sp.extinction[all.populations$spp.name==most.recent.spp]); extinct.time.most.recent;
sub.phylo$root.time = temp.root.time + max(c(0,max.time.actual - extinct.time.most.recent)); sub.phylo$root.time;
sub.phylo = collapse.singles(timeSliceTree(sub.phylo,sliceTime=(max.time.actual - t),plot=F,drop.extinct = T));
num.of.spp = length(sub.phylo$tip.label);
if (root.only == 1) { sub.clade.loop.end = (num.of.spp+1) }
if (root.only == 0) { sub.clade.loop.end = max(sub.phylo$edge) }
for (c in (num.of.spp+1):sub.clade.loop.end) {
#pull out list of species names belonging to each subclade
sub.clade = clade.members(c, sub.phylo, tip.labels=T)
subset.populations = subset(all.populations, spp.name %in% as.numeric(sub.clade));
#sub.populations is the subset of populations specific to a particular clade and timeslice
sub.populations = subset(subset.populations, time.of.origin <= t & time.of.extinction > t)
#sub.clade.phylo is a specific simulation clade pulled from the phylogeny that was sliced at timeslice t
tips.to.drop2 = as.character(sub.phylo$tip.label[which(is.element(sub.phylo$tip.label,as.character(sub.populations$spp.name))==F)]);
# check to see if there are at least min.num.spp species for continuing with the analysis; if not increment skipped.clades
if((length(sub.phylo$tip.label) - length(tips.to.drop2)) < min.num.spp) {
skipped.clades = skipped.clades + 1
} else {
sub.clade.phylo = drop.tip(sub.phylo,tips.to.drop2);
sub.clade.phylo$root.time = max(dist.nodes(sub.clade.phylo)[1:Ntip(sub.clade.phylo),Ntip(sub.clade.phylo) + 1]); sub.clade.phylo$root.time;
sub.clade.phylo$origin.time = t - sub.clade.phylo$root.time; sub.clade.phylo$origin.time;
if (identical(sort(as.integer(unique(sub.populations$spp.name))) , sort(as.integer(sub.clade.phylo$tip.label)))==F ) {print(c(c,t,'Error: trimmed phylogeny does not contain the correct species')); break} else{};
reg.summary = regional.calc(sub.populations[,c('region','spp.name','time.of.origin','reg.env','extant')], sub.clade.phylo, as.integer(t));
#Note that extinction calculation must be done on subset.populations, not sub.populations
extinction = extinct.calc(subset.populations, timeslice=t)
reg.summary2 = merge(reg.summary,extinction[,c('region','extinction.rate')],by='region')
MRD.range = max(reg.summary$MRD,na.rm = T) - min(reg.summary$MRD,na.rm = T)
MRD.mean = mean(reg.summary$MRD,na.rm = T)
MRD.var = var(reg.summary$MRD,na.rm = T)
MRD.rich.slope = summary(lm(reg.summary$MRD ~ reg.summary$richness))$coef[2,1]
MRD.env.slope = summary(lm(reg.summary$MRD ~ reg.summary$reg.env))$coef[2,1]
PSV.range = max(reg.summary$PSV,na.rm = T) - min(reg.summary$PSV,na.rm = T)
PSV.mean = mean(reg.summary$PSV,na.rm = T)
PSV.var = var(reg.summary$PSV,na.rm = T)
PSV.rich.slope = summary(lm(reg.summary$PSV ~ reg.summary$richness))$coef[2,1]
PSV.env.slope = summary(lm(reg.summary$PSV ~ reg.summary$reg.env))$coef[2,1]
n.div.regions = length(reg.summary$region[reg.summary$richness > 1])
corr.results = cbind(xregion.analysis(reg.summary2),MRD.range,MRD.mean,MRD.var,MRD.rich.slope,MRD.env.slope,
PSV.range,PSV.mean,PSV.var,PSV.rich.slope,PSV.env.slope,n.div.regions)
#Pybus & Harvey (2000)'s gamma statistic
Gamma.stat = gammaStat(sub.clade.phylo)
#Calculate Blomberg's K for two traits: environmental optimum, and mean region of occurrence
spp.traits = aggregate(sub.populations$region, by = list(sub.populations$spp.name, sub.populations$env.opt),
function(x) mean(x, na.rm=T))
names(spp.traits) = c('spp.name','env.opt','region')
spp.env = spp.traits$env.opt
names(spp.env) = spp.traits$spp.name
BK.env = phylosig(sub.clade.phylo, spp.env[sub.clade.phylo$tip.label], method="K")
spp.reg = spp.traits$region
names(spp.reg) = spp.traits$spp.name
BK.reg = phylosig(sub.clade.phylo, spp.reg[sub.clade.phylo$tip.label], method="K")
output = rbind(output, cbind(sim=sim,clade.id = c, time = t, corr.results, gamma.stat = Gamma.stat,
clade.richness = length(unique(sub.populations$spp.name)),
BK.env = BK.env , BK.reg = BK.reg))
print(paste(sim,sub.clade.loop.end,c,t,date(),length(sub.clade.phylo$tip.label),sep="   "));
} # end third else
} # end sub clade for loop
} # end second else
}; # end timeslice loop
t
sub.species = as.character(unique(subset(all.populations,time.of.sp.origin <= t & time.of.sp.extinction > t, select = 'spp.name'))[,1]);
# Some species may be extant globally (extant==1) but in our boundary regions (0,11) only;
# we need to eliminate species that are not extant within regions 1-10 (which is all that is
# reflected in the all.populations dataframe)
time.slice.populations = all.populations;
time.slice.populations$extant = 0;
time.slice.populations$extant[time.slice.populations$time.of.origin <= t & time.slice.populations$time.of.extinction > t] = 1
extant.ornot = aggregate(time.slice.populations$extant,by=list(time.slice.populations$spp.name),sum)
extinct.species = as.character(extant.ornot[extant.ornot$x==0,'Group.1'])
# FIXME:
# Add more explanatory comments justifying why we don't need to consider species that existed
# at time t but went extinct before the present.
# In some cases (e.g. sim 1 or 2, t=6000), tips.to.drop includes all tips and so sub.phylo is empty.
# Does it make sense for this to ever happen? If not, fix it.
# If so, need to provide an if-else error catch both in the creation of sub.phylo,
# and of sub.clade.phylo inside the clade loop. (Sim 3, t = 156 bonks at that point)
# NOTE: code runs for sim==5 currently as a test case
sub.species2 = sub.species[!sub.species %in% extinct.species]
tips.to.drop = as.character(phylo.out$tip.label[!phylo.out$tip.label %in% sub.species2]);
sub.phylo = drop.tip(phylo.out,tips.to.drop);
temp.root.time = max(dist.nodes(sub.phylo)[1:Ntip(sub.phylo),Ntip(sub.phylo) + 1]); temp.root.time;
most.recent.spp = sub.phylo$tip.label[as.numeric(names(which.max(dist.nodes(sub.phylo)[1:Ntip(sub.phylo),Ntip(sub.phylo) + 1])))]; most.recent.spp;
extinct.time.most.recent = unique(all.populations$time.of.sp.extinction[all.populations$spp.name==most.recent.spp]); extinct.time.most.recent;
sub.phylo$root.time = temp.root.time + max(c(0,max.time.actual - extinct.time.most.recent)); sub.phylo$root.time;
sub.phylo = collapse.singles(timeSliceTree(sub.phylo,sliceTime=(max.time.actual - t),plot=F,drop.extinct = T));
num.of.spp = length(sub.phylo$tip.label);
if (root.only == 1) { sub.clade.loop.end = (num.of.spp+1) }
if (root.only == 0) { sub.clade.loop.end = max(sub.phylo$edge) }
c
num.of.spp
sub.clade = clade.members(c, sub.phylo, tip.labels=T)
subset.populations = subset(all.populations, spp.name %in% as.numeric(sub.clade));
#sub.populations is the subset of populations specific to a particular clade and timeslice
sub.populations = subset(subset.populations, time.of.origin <= t & time.of.extinction > t)
#sub.clade.phylo is a specific simulation clade pulled from the phylogeny that was sliced at timeslice t
tips.to.drop2 = as.character(sub.phylo$tip.label[which(is.element(sub.phylo$tip.label,as.character(sub.populations$spp.name))==F)]);
sub.clade.phylo = drop.tip(sub.phylo,tips.to.drop2);
sub.clade.phylo$root.time = max(dist.nodes(sub.clade.phylo)[1:Ntip(sub.clade.phylo),Ntip(sub.clade.phylo) + 1]); sub.clade.phylo$root.time;
sub.clade.phylo$origin.time = t - sub.clade.phylo$root.time; sub.clade.phylo$origin.time;
if (identical(sort(as.integer(unique(sub.populations$spp.name))) , sort(as.integer(sub.clade.phylo$tip.label)))==F ) {print(c(c,t,'Error: trimmed phylogeny does not contain the correct species')); break} else{};
reg.summary = regional.calc(sub.populations[,c('region','spp.name','time.of.origin','reg.env','extant')], sub.clade.phylo, as.integer(t));
reg.summary
#Note that extinction calculation must be done on subset.populations, not sub.populations
extinction = extinct.calc(subset.populations, timeslice=t)
reg.summary2 = merge(reg.summary,extinction[,c('region','extinction.rate')],by='region')
MRD.range = max(reg.summary$MRD,na.rm = T) - min(reg.summary$MRD,na.rm = T)
MRD.mean = mean(reg.summary$MRD,na.rm = T)
MRD.var = var(reg.summary$MRD,na.rm = T)
MRD.rich.slope = summary(lm(reg.summary$MRD ~ reg.summary$richness))$coef[2,1]
MRD.env.slope = summary(lm(reg.summary$MRD ~ reg.summary$reg.env))$coef[2,1]
PSV.range = max(reg.summary$PSV,na.rm = T) - min(reg.summary$PSV,na.rm = T)
PSV.mean = mean(reg.summary$PSV,na.rm = T)
PSV.var = var(reg.summary$PSV,na.rm = T)
PSV.rich.slope = summary(lm(reg.summary$PSV ~ reg.summary$richness))$coef[2,1]
summary(lm(reg.summary$PSV ~ reg.summary$richness))
summary(lm(reg.summary$PSV ~ reg.summary$richness))$coef
lm(reg.summary$PSV ~ reg.summary$richness)
str(lm(reg.summary$PSV ~ reg.summary$richness))
lm(reg.summary$PSV ~ reg.summary$richness)$coefficients
PSV.rich.slope = lm(reg.summary$PSV ~ reg.summary$richness)$coefficients[2]
PSV.rich.slope
PSV.rich.slope = lm(reg.summary$PSV ~ reg.summary$richness)$coefficients[2]
PSV.rich.slope
summary(lm(reg.summary$MRD ~ reg.summary$richness))
lm(reg.summary$MRD ~ reg.summary$richness)
MRD.rich.slope = lm(reg.summary$MRD ~ reg.summary$richness)$coefficients[2]
MRD.env.slope = lm(reg.summary$MRD ~ reg.summary$reg.env)$coefficients[2]
MRD.rich.slope
MRD.env.slope
PSV.rich.slope = lm(reg.summary$PSV ~ reg.summary$richness)$coefficients[2]
PSV.env.slope = lm(reg.summary$PSV ~ reg.summary$reg.env)$coefficients[2]
PSV.rich.slope
PSV.env.slope
lm(reg.summary$PSV ~ reg.summary$reg.env)
MRD.range = max(reg.summary$MRD,na.rm = T) - min(reg.summary$MRD,na.rm = T)
MRD.mean = mean(reg.summary$MRD,na.rm = T)
MRD.var = var(reg.summary$MRD,na.rm = T)
MRD.rich.slope = lm(reg.summary$MRD ~ reg.summary$richness)$coefficients[2]
MRD.env.slope = lm(reg.summary$MRD ~ reg.summary$reg.env)$coefficients[2]
PSV.range = max(reg.summary$PSV,na.rm = T) - min(reg.summary$PSV,na.rm = T)
PSV.mean = mean(reg.summary$PSV,na.rm = T)
PSV.var = var(reg.summary$PSV,na.rm = T)
PSV.rich.slope = lm(reg.summary$PSV ~ reg.summary$richness)$coefficients[2]
PSV.env.slope = lm(reg.summary$PSV ~ reg.summary$reg.env)$coefficients[2]
n.div.regions = length(reg.summary$region[reg.summary$richness > 1])
corr.results = cbind(xregion.analysis(reg.summary2),MRD.range,MRD.mean,MRD.var,MRD.rich.slope,MRD.env.slope,
PSV.range,PSV.mean,PSV.var,PSV.rich.slope,PSV.env.slope,n.div.regions)
corr.results
output = numeric();
skipped.clades = 0
skipped.times = ""
for (t in timeslices) {
# vector of species in existence at time t
sub.species = as.character(unique(subset(all.populations,time.of.sp.origin <= t & time.of.sp.extinction > t, select = 'spp.name'))[,1]);
# Some species may be extant globally (extant==1) but in our boundary regions (0,11) only;
# we need to eliminate species that are not extant within regions 1-10 (which is all that is
# reflected in the all.populations dataframe)
time.slice.populations = all.populations;
time.slice.populations$extant = 0;
time.slice.populations$extant[time.slice.populations$time.of.origin <= t & time.slice.populations$time.of.extinction > t] = 1
extant.ornot = aggregate(time.slice.populations$extant,by=list(time.slice.populations$spp.name),sum)
extinct.species = as.character(extant.ornot[extant.ornot$x==0,'Group.1'])
# FIXME:
# Add more explanatory comments justifying why we don't need to consider species that existed
# at time t but went extinct before the present.
# In some cases (e.g. sim 1 or 2, t=6000), tips.to.drop includes all tips and so sub.phylo is empty.
# Does it make sense for this to ever happen? If not, fix it.
# If so, need to provide an if-else error catch both in the creation of sub.phylo,
# and of sub.clade.phylo inside the clade loop. (Sim 3, t = 156 bonks at that point)
# NOTE: code runs for sim==5 currently as a test case
sub.species2 = sub.species[!sub.species %in% extinct.species]
tips.to.drop = as.character(phylo.out$tip.label[!phylo.out$tip.label %in% sub.species2]);
# check to see if there are at least min.num.spp species for continuing with the analysis; if not store the skipped timeslice
if ( (length(phylo.out$tip.label) - length(tips.to.drop)) < min.num.spp) {
skipped.times = paste(skipped.times, t) # keep track of the timeslices that were skipped in a text string
} else {
sub.phylo = drop.tip(phylo.out,tips.to.drop);
temp.root.time = max(dist.nodes(sub.phylo)[1:Ntip(sub.phylo),Ntip(sub.phylo) + 1]); temp.root.time;
most.recent.spp = sub.phylo$tip.label[as.numeric(names(which.max(dist.nodes(sub.phylo)[1:Ntip(sub.phylo),Ntip(sub.phylo) + 1])))]; most.recent.spp;
extinct.time.most.recent = unique(all.populations$time.of.sp.extinction[all.populations$spp.name==most.recent.spp]); extinct.time.most.recent;
sub.phylo$root.time = temp.root.time + max(c(0,max.time.actual - extinct.time.most.recent)); sub.phylo$root.time;
sub.phylo = collapse.singles(timeSliceTree(sub.phylo,sliceTime=(max.time.actual - t),plot=F,drop.extinct = T));
num.of.spp = length(sub.phylo$tip.label);
if (root.only == 1) { sub.clade.loop.end = (num.of.spp+1) }
if (root.only == 0) { sub.clade.loop.end = max(sub.phylo$edge) }
for (c in (num.of.spp+1):sub.clade.loop.end) {
#pull out list of species names belonging to each subclade
sub.clade = clade.members(c, sub.phylo, tip.labels=T)
subset.populations = subset(all.populations, spp.name %in% as.numeric(sub.clade));
#sub.populations is the subset of populations specific to a particular clade and timeslice
sub.populations = subset(subset.populations, time.of.origin <= t & time.of.extinction > t)
#sub.clade.phylo is a specific simulation clade pulled from the phylogeny that was sliced at timeslice t
tips.to.drop2 = as.character(sub.phylo$tip.label[which(is.element(sub.phylo$tip.label,as.character(sub.populations$spp.name))==F)]);
# check to see if there are at least min.num.spp species for continuing with the analysis; if not increment skipped.clades
if((length(sub.phylo$tip.label) - length(tips.to.drop2)) < min.num.spp) {
skipped.clades = skipped.clades + 1
} else {
sub.clade.phylo = drop.tip(sub.phylo,tips.to.drop2);
sub.clade.phylo$root.time = max(dist.nodes(sub.clade.phylo)[1:Ntip(sub.clade.phylo),Ntip(sub.clade.phylo) + 1]); sub.clade.phylo$root.time;
sub.clade.phylo$origin.time = t - sub.clade.phylo$root.time; sub.clade.phylo$origin.time;
if (identical(sort(as.integer(unique(sub.populations$spp.name))) , sort(as.integer(sub.clade.phylo$tip.label)))==F ) {print(c(c,t,'Error: trimmed phylogeny does not contain the correct species')); break} else{};
reg.summary = regional.calc(sub.populations[,c('region','spp.name','time.of.origin','reg.env','extant')], sub.clade.phylo, as.integer(t));
#Note that extinction calculation must be done on subset.populations, not sub.populations
extinction = extinct.calc(subset.populations, timeslice=t)
reg.summary2 = merge(reg.summary,extinction[,c('region','extinction.rate')],by='region')
MRD.range = max(reg.summary$MRD,na.rm = T) - min(reg.summary$MRD,na.rm = T)
MRD.mean = mean(reg.summary$MRD,na.rm = T)
MRD.var = var(reg.summary$MRD,na.rm = T)
MRD.rich.slope = lm(reg.summary$MRD ~ reg.summary$richness)$coefficients[2]
MRD.env.slope = lm(reg.summary$MRD ~ reg.summary$reg.env)$coefficients[2]
PSV.range = max(reg.summary$PSV,na.rm = T) - min(reg.summary$PSV,na.rm = T)
PSV.mean = mean(reg.summary$PSV,na.rm = T)
PSV.var = var(reg.summary$PSV,na.rm = T)
PSV.rich.slope = lm(reg.summary$PSV ~ reg.summary$richness)$coefficients[2]
PSV.env.slope = lm(reg.summary$PSV ~ reg.summary$reg.env)$coefficients[2]
n.div.regions = length(reg.summary$region[reg.summary$richness > 1])
corr.results = cbind(xregion.analysis(reg.summary2),MRD.range,MRD.mean,MRD.var,MRD.rich.slope,MRD.env.slope,
PSV.range,PSV.mean,PSV.var,PSV.rich.slope,PSV.env.slope,n.div.regions)
#Pybus & Harvey (2000)'s gamma statistic
Gamma.stat = gammaStat(sub.clade.phylo)
#Calculate Blomberg's K for two traits: environmental optimum, and mean region of occurrence
spp.traits = aggregate(sub.populations$region, by = list(sub.populations$spp.name, sub.populations$env.opt),
function(x) mean(x, na.rm=T))
names(spp.traits) = c('spp.name','env.opt','region')
spp.env = spp.traits$env.opt
names(spp.env) = spp.traits$spp.name
BK.env = phylosig(sub.clade.phylo, spp.env[sub.clade.phylo$tip.label], method="K")
spp.reg = spp.traits$region
names(spp.reg) = spp.traits$spp.name
BK.reg = phylosig(sub.clade.phylo, spp.reg[sub.clade.phylo$tip.label], method="K")
output = rbind(output, cbind(sim=sim,clade.id = c, time = t, corr.results, gamma.stat = Gamma.stat,
clade.richness = length(unique(sub.populations$spp.name)),
BK.env = BK.env , BK.reg = BK.reg))
print(paste(sim,sub.clade.loop.end,c,t,date(),length(sub.clade.phylo$tip.label),sep="   "));
} # end third else
} # end sub clade for loop
} # end second else
}; # end timeslice loop
head(output)
