meta.pca.scores
bnti.ses
rownames(meta.pca.scores)
cbind(rownames(meta.pca.scores),rownames(bnti.ses))
rm(list=ls());
formation.one = "Ringold";
formation.two = "RingoldE";
library(vegan); library(leaps);
#bnti = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Emp_betaNTI_weighted.csv",header=T,row.names=1); bnti[1:5,1:5];
bnti.ses = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment.SES.Weighted.Neighbor.csv",header=T,row.names=1); bnti.ses = as.matrix(as.dist(bnti.ses)); bnti.ses[1:5,1:5];
bray = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Bray_Curtis_Dissimilary.csv",row.names=1,header=T); bray[1:5,1:5];
#sor = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Sorensen_Dissimilary.csv",row.names=1,header=T); sor[1:5,1:5];
#rc.inc = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_RC_Dissimilary.csv",row.names=1,header=T); rc.inc[1:5,1:5];
rc.abun = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_RC_Abund_Dissimilary.csv",row.names=1,header=T); rc.abun[1:5,1:5];
meta.data = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Metadata.csv",header=T); rownames(meta.data) = meta.data[,'CuID']; head(meta.data); dim(meta.data); ## all metadata, including environmental data
geo.dist = as.data.frame(meta.data[,c('Easting','Northing')]); geo.dist; geo.dist = as.matrix(dist(geo.dist)); geo.dist[1:5,1:5]; range(geo.dist[geo.dist!=0]);
## trimming all matricies to include only those sites within the Ringold
selected.sites = meta.data$CuID[meta.data$StrataUnit == formation.one | meta.data$StrataUnit == formation.two]; selected.sites; length(selected.sites);
bnti.ses = bnti.ses[is.element(rownames(bnti.ses),selected.sites),is.element(colnames(bnti.ses),selected.sites)]; bnti.ses[1:5,1:5]; dim(bnti.ses);
bray = bray[is.element(rownames(bray),selected.sites),is.element(colnames(bray),selected.sites)]; bray[1:5,1:5]; dim(bray);
rc.abun = rc.abun[is.element(rownames(rc.abun),selected.sites),is.element(colnames(rc.abun),selected.sites)]; rc.abun[1:5,1:5]; dim(rc.abun);
rc.abun.dist = as.dist(rc.abun); length(rc.abun.dist[abs(rc.abun.dist)>0.95]) / length(rc.abun.dist); rm('rc.abun.dist'); ## 40 % of comparisons are significant
geo.dist = geo.dist[is.element(rownames(geo.dist),selected.sites),is.element(colnames(geo.dist),selected.sites)]; geo.dist[1:5,1:5]; dim(geo.dist);
pcnm.out = pcnm(geo.dist);
spatial.predictors = as.data.frame(pcnm.out$vectors); head(spatial.predictors);
spatial.predictors$CuID = rownames(spatial.predictors); head(spatial.predictors);
## merge meta data with pcnm axes
meta.pcnm = merge(meta.data,spatial.predictors,by="CuID"); head(meta.pcnm); dim(meta.pcnm); # merge pcnm vectors with meta data
rownames(meta.pcnm) = meta.pcnm$CuID;
meta.pcnm.for.vis = meta.pcnm;
meta.pcnm = meta.pcnm[,c("RingoldElev_ft","percent_mud_pred","NEAR_DIST_m","Core_Elevation_m",colnames(pcnm.out$vectors))]; head(meta.pcnm);
## pca on all meta data with pcnm axes
source("C:/Users/steg815/Desktop/Stegen_PNNL/R_Functions/z.score.fun.r");
for (i in 1:ncol(meta.pcnm)) { meta.pcnm[,i] = z.score.fun(meta.pcnm[,i]); print(c(mean(meta.pcnm[,i]),sd(meta.pcnm[,i]))); }
meta.pca = princomp(meta.pcnm); rm('meta.pcnm');
summary(meta.pca);
loadings(meta.pca);
meta.pca.scores = as.data.frame(meta.pca$scores); head(meta.pca.scores);
pca.predictors = meta.pca.scores; pca.predictors$CuID = rownames(pca.predictors); head(pca.predictors);
bnti.ses.dbrda.int = capscale(as.dist(bnti.ses) ~ 1,data=meta.pca.scores);
bnti.ses.dbrda.full = capscale(as.dist(bnti.ses) ~ .,data=meta.pca.scores);
bnti.ses.select.rsq = ordiR2step(bnti.ses.dbrda.int, scope = formula(bnti.ses.dbrda.full),direction = "both",pstep=1000, perm.max = 1000); bnti.ses.select.rsq;
bnti.ses = bnti.ses + abs(min(bnti.ses));
bnti.ses  = bnti.ses / max(bnti.ses);
range(bnti.ses)
bnti.ses.dbrda.int = capscale(as.dist(bnti.ses) ~ 1,data=meta.pca.scores);
bnti.ses.dbrda.full = capscale(as.dist(bnti.ses) ~ .,data=meta.pca.scores);
bnti.ses.select.rsq = ordiR2step(bnti.ses.dbrda.int, scope = formula(bnti.ses.dbrda.full),direction = "both",pstep=1000, perm.max = 1000); bnti.ses.select.rsq;
loadings(meta.pca);
#### Code for analyses of spatial microbe dataset from the Hanford IFRC sediment ####
#### start beta diversity analyses using PCNM and dbRDA and PCA
## also relating NTI to pcnm axes as potential environmental variables (i.e. identifying any further environmental variables)
rm(list=ls());
library(vegan); library(scatterplot3d);
#bnti = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Emp_betaNTI_weighted.csv",header=T,row.names=1); bnti[1:5,1:5];
bnti.ses = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment.SES.Weighted.Neighbor.csv",header=T,row.names=1); bnti.ses = as.matrix(as.dist(bnti.ses)); bnti.ses[1:5,1:5];
bray = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Bray_Curtis_Dissimilary.csv",row.names=1,header=T); bray[1:5,1:5];
#sor = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Sorensen_Dissimilary.csv",row.names=1,header=T); sor[1:5,1:5];
#rc.inc = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_RC_Dissimilary.csv",row.names=1,header=T); rc.inc[1:5,1:5];
rc.abun = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_RC_Abund_Dissimilary.csv",row.names=1,header=T); rc.abun[1:5,1:5];
rc.abun.dist = as.dist(rc.abun); length(rc.abun.dist[abs(rc.abun.dist)>0.95]) / length(rc.abun.dist); rm('rc.abun.dist'); ## 65 % of comparisons are significant
meta.data = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Metadata.csv",header=T); rownames(meta.data) = meta.data[,'CuID']; head(meta.data); dim(meta.data); ## all metadata, including environmental data
geo.dist = as.data.frame(meta.data[,c('Easting','Northing','Core_Elevation_m')]); geo.dist; geo.dist = as.matrix(dist(geo.dist)); geo.dist[1:5,1:5]; range(geo.dist[geo.dist!=0]);
pcnm.out = pcnm(geo.dist);
spatial.predictors = as.data.frame(pcnm.out$vectors); head(spatial.predictors);
spatial.predictors$CuID = rownames(spatial.predictors); head(spatial.predictors);
## merge meta data with pcnm axes
meta.pcnm = merge(meta.data,spatial.predictors,by="CuID"); head(meta.pcnm); dim(meta.pcnm); # merge pcnm vectors with meta data
rownames(meta.pcnm) = meta.pcnm$CuID;
meta.pcnm.for.vis = meta.pcnm;
meta.pcnm = meta.pcnm[,c("RingoldElev_ft","percent_mud_pred","NEAR_DIST_m","Core_Elevation_m",colnames(pcnm.out$vectors))]; head(meta.pcnm);
## pca on all meta data with pcnm axes
source("C:/Users/steg815/Desktop/Stegen_PNNL/R_Functions/z.score.fun.r");
for (i in 1:ncol(meta.pcnm)) { meta.pcnm[,i] = z.score.fun(meta.pcnm[,i]); print(c(mean(meta.pcnm[,i]),sd(meta.pcnm[,i]))); }
meta.pca = princomp(meta.pcnm); rm('meta.pcnm');
summary(meta.pca);
loadings(meta.pca);
meta.pca.scores = as.data.frame(meta.pca$scores);
pca.predictors = meta.pca.scores; pca.predictors$CuID = rownames(pca.predictors); head(pca.predictors);
meta.pca.for.vis = pca.predictors;
meta.pca.for.vis$CuID = rownames(meta.pca.for.vis);
meta.pca.for.vis = merge(meta.data,meta.pca.for.vis,by="CuID"); head(meta.pca.for.vis); dim(meta.pca.for.vis); # pca with meta data for visualization
bnti.ses.dbrda.int = capscale(as.dist(bnti.ses) ~ 1,data=meta.pca.scores);
bnti.ses.dbrda.full = capscale(as.dist(bnti.ses) ~ .,data=meta.pca.scores);
bnti.ses.select.rsq = ordiR2step(bnti.ses.dbrda.int, scope = formula(bnti.ses.dbrda.full),direction = "both",pstep=1000, perm.max = 1000); bnti.ses.select.rsq;
bnti.ses.dbrda.int = capscale(as.dist(bnti.ses) ~ 1,data=meta.pca.scores);
bnti.ses.dbrda.full = capscale(as.dist(bnti.ses) ~ .,data=meta.pca.scores);
bnti.ses.select.rsq = ordiR2step(bnti.ses.dbrda.int, scope = formula(bnti.ses.dbrda.full),direction = "both",pstep=1000, perm.max = 1000); bnti.ses.select.rsq;
rm(list=ls());
formation.one = "Ringold";
formation.two = "RingoldE";
library(vegan); library(leaps);
bnti.ses = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment.SES.Weighted.Neighbor.csv",header=T,row.names=1); bnti.ses = as.matrix(as.dist(bnti.ses)); bnti.ses[1:5,1:5];
bray = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Bray_Curtis_Dissimilary.csv",row.names=1,header=T); bray[1:5,1:5];
rc.abun = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_RC_Abund_Dissimilary.csv",row.names=1,header=T); rc.abun[1:5,1:5];
meta.data = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Metadata.csv",header=T); rownames(meta.data) = meta.data[,'CuID']; head(meta.data); dim(meta.data); ## all metadata, including environmental data
geo.dist = as.data.frame(meta.data[,c('Easting','Northing')]); geo.dist; geo.dist = as.matrix(dist(geo.dist)); geo.dist[1:5,1:5]; range(geo.dist[geo.dist!=0]);
## trimming all matricies to include only those sites within the Ringold
selected.sites = meta.data$CuID[meta.data$StrataUnit == formation.one | meta.data$StrataUnit == formation.two]; selected.sites; length(selected.sites);
bnti.ses = bnti.ses[is.element(rownames(bnti.ses),selected.sites),is.element(colnames(bnti.ses),selected.sites)]; bnti.ses[1:5,1:5]; dim(bnti.ses);
bray = bray[is.element(rownames(bray),selected.sites),is.element(colnames(bray),selected.sites)]; bray[1:5,1:5]; dim(bray);
rc.abun = rc.abun[is.element(rownames(rc.abun),selected.sites),is.element(colnames(rc.abun),selected.sites)]; rc.abun[1:5,1:5]; dim(rc.abun);
rc.abun.dist = as.dist(rc.abun); length(rc.abun.dist[abs(rc.abun.dist)>0.95]) / length(rc.abun.dist); rm('rc.abun.dist'); ## 40 % of comparisons are significant
geo.dist = geo.dist[is.element(rownames(geo.dist),selected.sites),is.element(colnames(geo.dist),selected.sites)]; geo.dist[1:5,1:5]; dim(geo.dist);
pcnm.out = pcnm(geo.dist);
spatial.predictors = as.data.frame(pcnm.out$vectors); head(spatial.predictors);
spatial.predictors$CuID = rownames(spatial.predictors); head(spatial.predictors);
## merge meta data with pcnm axes
meta.pcnm = merge(meta.data,spatial.predictors,by="CuID"); head(meta.pcnm); dim(meta.pcnm); # merge pcnm vectors with meta data
rownames(meta.pcnm) = meta.pcnm$CuID;
meta.pcnm.for.vis = meta.pcnm;
meta.pcnm = meta.pcnm[,c("RingoldElev_ft","percent_mud_pred","NEAR_DIST_m","Core_Elevation_m",colnames(pcnm.out$vectors))]; head(meta.pcnm);
## pca on all meta data with pcnm axes
source("C:/Users/steg815/Desktop/Stegen_PNNL/R_Functions/z.score.fun.r");
for (i in 1:ncol(meta.pcnm)) { meta.pcnm[,i] = z.score.fun(meta.pcnm[,i]); print(c(mean(meta.pcnm[,i]),sd(meta.pcnm[,i]))); }
meta.pca = princomp(meta.pcnm); rm('meta.pcnm');
summary(meta.pca);
loadings(meta.pca);
write.csv(loadings(meta.pca),"C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_PCA_Loadings_Ringold.csv",row.names=T,quote=F);
meta.pca.scores = as.data.frame(meta.pca$scores); head(meta.pca.scores);
pca.predictors = meta.pca.scores; pca.predictors$CuID = rownames(pca.predictors); head(pca.predictors);
bnti.ses = bnti.ses + abs(min(bnti.ses));
bnti.ses = bnti.ses/max(bnti.ses);
range(bnti.ses);
bnti.ses.dbrda.int = capscale(as.dist(bnti.ses) ~ 1,data=meta.pca.scores);
bnti.ses.dbrda.full = capscale(as.dist(bnti.ses) ~ .,data=meta.pca.scores);
bnti.ses.select.rsq = ordiR2step(bnti.ses.dbrda.int, scope = formula(bnti.ses.dbrda.full),direction = "both",pstep=1000, perm.max = 1000); bnti.ses.select.rsq;
bnti.ses.select.rsq = ordiR2step(bnti.ses.dbrda.int, scope = formula(bnti.ses.dbrda.full),direction = "both",pstep=10000, perm.max = 100000); bnti.ses.select.rsq;
full.bnti.ses.model = capscale(formula = as.dist(bnti.ses) ~ Comp.7 + Comp.6, data = meta.pca.scores); plot(full.bnti.ses.model);
bnti.ses.full.rsq = RsquareAdj(full.bnti.ses.model)$r.squared; bnti.ses.full.rsq; ## 0.4355125 for regular r.sq and 0.395192 for adjusted r.sq, all considered to reflect environmental influences
RsquareAdj(full.bnti.ses.model)
cbind(rownames(bnti.ses),colnames(bnti.ses),rownames(meta.pca.scores));
?identical
identical(rownames(bnti.ses),colnames(bnti.ses))
identical(rownames(bnti.ses),rownames(meta.pca.scores))
identical(rownames(bray),colnames(bray)); # must be TRUE to proceed
identical(rownames(bray),rownames(bray)); # must be TRUE to proceed
bnti.ses.full.rsq = RsquareAdj(full.bnti.ses.model)$r.squared; bnti.ses.full.rsq; ## 0.4856486 for regular r.sq and 0.4065176 for adjusted r.sq, all considered to reflect environmental influences
bray.dbrda.int = capscale(as.dist(bray) ~ 1,data=meta.pca.scores);
bray.dbrda.full = capscale(as.dist(bray) ~ .,data=meta.pca.scores);
bray.select.rsq = ordiR2step(bray.dbrda.int, scope = formula(bray.dbrda.full),direction = "both",pstep=1000, perm.max = 100000); bray.select.rsq;
bray.select.rsq = ordiR2step(bray.dbrda.int, scope = formula(bray.dbrda.full),direction = "both",pstep=1000, perm.max = 100000); bray.select.rsq;
bray.select.rsq = ordiR2step(bray.dbrda.int, scope = formula(bray.dbrda.full),direction = "both",pstep=1000, perm.max = 1000); bray.select.rsq;
full.bray.model = capscale(as.dist(bray) ~ , data = meta.pca.scores); ## nothing is significant
full.bray.model = capscale(as.dist(bray) ~ Comp.6, data = meta.pca.scores); ## nothing is significant
anova(full.bray.model)
install.packages('vegan')
install.packages('vegan')
library(vegan); library(leaps);
update.packages(checkBuilt=TRUE, ask=FALSE)
install.packages('vegan')
library(vegan)
rm(list=ls());
formation.one = "Ringold";
formation.two = "RingoldE";
library(vegan); library(leaps);
#bnti = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Emp_betaNTI_weighted.csv",header=T,row.names=1); bnti[1:5,1:5];
bnti.ses = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment.SES.Weighted.Neighbor.csv",header=T,row.names=1); bnti.ses = as.matrix(as.dist(bnti.ses)); bnti.ses[1:5,1:5];
bray = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Bray_Curtis_Dissimilary.csv",row.names=1,header=T); bray[1:5,1:5];
#sor = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Sorensen_Dissimilary.csv",row.names=1,header=T); sor[1:5,1:5];
#rc.inc = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_RC_Dissimilary.csv",row.names=1,header=T); rc.inc[1:5,1:5];
rc.abun = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_RC_Abund_Dissimilary.csv",row.names=1,header=T); rc.abun[1:5,1:5];
meta.data = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Sediment_Metadata.csv",header=T); rownames(meta.data) = meta.data[,'CuID']; head(meta.data); dim(meta.data); ## all metadata, including environmental data
geo.dist = as.data.frame(meta.data[,c('Easting','Northing')]); geo.dist; geo.dist = as.matrix(dist(geo.dist)); geo.dist[1:5,1:5]; range(geo.dist[geo.dist!=0]);
## trimming all matricies to include only those sites within the Ringold
selected.sites = meta.data$CuID[meta.data$StrataUnit == formation.one | meta.data$StrataUnit == formation.two]; selected.sites; length(selected.sites);
bnti.ses = bnti.ses[is.element(rownames(bnti.ses),selected.sites),is.element(colnames(bnti.ses),selected.sites)]; bnti.ses[1:5,1:5]; dim(bnti.ses);
bray = bray[is.element(rownames(bray),selected.sites),is.element(colnames(bray),selected.sites)]; bray[1:5,1:5]; dim(bray);
rc.abun = rc.abun[is.element(rownames(rc.abun),selected.sites),is.element(colnames(rc.abun),selected.sites)]; rc.abun[1:5,1:5]; dim(rc.abun);
rc.abun.dist = as.dist(rc.abun); length(rc.abun.dist[abs(rc.abun.dist)>0.95]) / length(rc.abun.dist); rm('rc.abun.dist'); ## 40 % of comparisons are significant
geo.dist = geo.dist[is.element(rownames(geo.dist),selected.sites),is.element(colnames(geo.dist),selected.sites)]; geo.dist[1:5,1:5]; dim(geo.dist);
pcnm.out = pcnm(geo.dist);
spatial.predictors = as.data.frame(pcnm.out$vectors); head(spatial.predictors);
spatial.predictors$CuID = rownames(spatial.predictors); head(spatial.predictors);
## merge meta data with pcnm axes
meta.pcnm = merge(meta.data,spatial.predictors,by="CuID"); head(meta.pcnm); dim(meta.pcnm); # merge pcnm vectors with meta data
rownames(meta.pcnm) = meta.pcnm$CuID;
meta.pcnm.for.vis = meta.pcnm;
meta.pcnm = meta.pcnm[,c("RingoldElev_ft","percent_mud_pred","NEAR_DIST_m","Core_Elevation_m",colnames(pcnm.out$vectors))]; head(meta.pcnm);
## pca on all meta data with pcnm axes
source("C:/Users/steg815/Desktop/Stegen_PNNL/R_Functions/z.score.fun.r");
for (i in 1:ncol(meta.pcnm)) { meta.pcnm[,i] = z.score.fun(meta.pcnm[,i]); print(c(mean(meta.pcnm[,i]),sd(meta.pcnm[,i]))); }
meta.pca = princomp(meta.pcnm); rm('meta.pcnm');
summary(meta.pca);
loadings(meta.pca);
?princomp
meta.pca = princomp(meta.pcnm); rm('meta.pcnm');
meta.pcnm = merge(meta.data,spatial.predictors,by="CuID"); head(meta.pcnm); dim(meta.pcnm); # merge pcnm vectors with meta data
rownames(meta.pcnm) = meta.pcnm$CuID;
meta.pcnm.for.vis = meta.pcnm;
meta.pcnm = meta.pcnm[,c("RingoldElev_ft","percent_mud_pred","NEAR_DIST_m","Core_Elevation_m",colnames(pcnm.out$vectors))]; head(meta.pcnm);
## pca on all meta data with pcnm axes
source("C:/Users/steg815/Desktop/Stegen_PNNL/R_Functions/z.score.fun.r");
for (i in 1:ncol(meta.pcnm)) { meta.pcnm[,i] = z.score.fun(meta.pcnm[,i]); print(c(mean(meta.pcnm[,i]),sd(meta.pcnm[,i]))); }
meta.pca = princomp(meta.pcnm);
meta.pca = prcomp(meta.pcnm);
summary(meta.pca);
loadings(meta.pca);
meta.pca$rotation;
str(meta.pca)
meta.pca$x
meta.pca.scores = as.data.frame(meta.pca$scores); head(meta.pca.scores);
meta.pca.scores = as.data.frame(meta.pca$x); head(meta.pca.scores);
pca.predictors = meta.pca.scores; pca.predictors$CuID = rownames(pca.predictors); head(pca.predictors);
bnti.ses = bnti.ses + abs(min(bnti.ses));
bnti.ses = bnti.ses/max(bnti.ses);
range(bnti.ses);
identical(rownames(bnti.ses),colnames(bnti.ses)); # must be TRUE to proceed
identical(rownames(bnti.ses),rownames(meta.pca.scores)); # must be TRUE to proceed
bnti.ses.dbrda.int = capscale(as.dist(bnti.ses) ~ 1,data=meta.pca.scores);
bnti.ses.dbrda.full = capscale(as.dist(bnti.ses) ~ .,data=meta.pca.scores);
bnti.ses.select.rsq = ordiR2step(bnti.ses.dbrda.int, scope = formula(bnti.ses.dbrda.full),direction = "both",pstep=10000, perm.max = 100000); bnti.ses.select.rsq;
identical(rownames(bray),colnames(bray)); # must be TRUE to proceed
identical(rownames(bray),rownames(bray)); # must be TRUE to proceed
bray.dbrda.int = capscale(as.dist(bray) ~ 1,data=meta.pca.scores);
bray.dbrda.full = capscale(as.dist(bray) ~ .,data=meta.pca.scores);
bray.select.rsq = ordiR2step(bray.dbrda.int, scope = formula(bray.dbrda.full),direction = "both",pstep=1000, perm.max = 1000); bray.select.rsq;
rc.abun.dbrda.int = capscale(as.dist(rc.abun) ~ 1,data=meta.pca.scores);
rc.abun.dbrda.full = capscale(as.dist(rc.abun) ~ .,data=meta.pca.scores);
rc.abun.select.rsq = ordiR2step(rc.abun.dbrda.int, scope = formula(rc.abun.dbrda.full),direction = "both",pstep=1000, perm.max = 1000); rc.abun.select.rsq;
rc.abun = rc.abun + abs(min(rc.abun));
range(rc.abun);
rc.abun = rc.abun / max(rc.abun);
range(rc.abun);
rc.abun.dbrda.int = capscale(as.dist(rc.abun) ~ 1,data=meta.pca.scores);
rc.abun.dbrda.full = capscale(as.dist(rc.abun) ~ .,data=meta.pca.scores);
rc.abun.select.rsq = ordiR2step(rc.abun.dbrda.int, scope = formula(rc.abun.dbrda.full),direction = "both",pstep=1000, perm.max = 1000); rc.abun.select.rsq;
meta.pcnm = merge(meta.data,spatial.predictors,by="CuID"); head(meta.pcnm); dim(meta.pcnm); # merge pcnm vectors with meta data
rownames(meta.pcnm) = meta.pcnm$CuID;
meta.pcnm.for.vis = meta.pcnm;
meta.pcnm = meta.pcnm[,c("RingoldElev_ft","percent_mud_pred","NEAR_DIST_m","Core_Elevation_m",colnames(pcnm.out$vectors))]; head(meta.pcnm);
## pca on all meta data with pcnm axes
source("C:/Users/steg815/Desktop/Stegen_PNNL/R_Functions/z.score.fun.r");
for (i in 1:ncol(meta.pcnm)) { meta.pcnm[,i] = z.score.fun(meta.pcnm[,i]); print(c(mean(meta.pcnm[,i]),sd(meta.pcnm[,i]))); }
meta.pca = princomp(meta.pcnm); rm('meta.pcnm');
loadings(meta.pca)
head(spatial.predictors);
orig.pcnm = read.csv("Ringold_PCNM_Orig.csv",header=T,row.names=1); head(orig.pcnm)
getwd
getwd()
orig.pcnm = read.csv(""C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Ringold_PCNM_Orig.csv",header=T,row.names=1); head(orig.pcnm)
orig.pcnm = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Ringold_PCNM_Orig.csv",header=T,row.names=1); head(orig.pcnm)
identical(orig.pcnm,spatial.predictors)
class(orig.pcnm)
class(spatial.predictors)
identical(orig.pcnm[,1:5],spatial.predictors[,1:5])
identical(orig.pcnm[,1],spatial.predictors[,1])
plot(orig.pcnm[,1],spatial.predictors[,1])
abline(0,1)
str(orig.pcnm)
str(spatial.predictors)
orig.pcnm$CuID = as.character(orig.pcnm$CuID)
str(orig.pcnm)
identical(orig.pcnm,spatial.predictors)
identical(orig.pcnm[,7],spatial.predictors[,7])
cbind(orig.pcnm[,7],spatial.predictors[,7])
cbind(orig.pcnm[,8],spatial.predictors[,8])
identical(orig.pcnm[,8],spatial.predictors[,8])
identical(orig.pcnm[,8],spatial.predictors[,8])
plot(orig.pcnm[,1:7],spatial.predictors[,1:7])
plot(as.vector(orig.pcnm[,1:7]),as.vector(spatial.predictors[,1:7]))
as.vector(orig.pcnm[,1:7])
c(orig.pcnm[,1:7])
plot(orig.pcnm[,1],spatial.predictors[,1])
plot(orig.pcnm[,1],spatial.predictors[,1]); abline(0,1); summary(lm(orig.pcnm[,1]~spatial.predictors[,1]))
for (i in 1:7) {
plot(orig.pcnm[,i],spatial.predictors[,i]); abline(0,1); print(summary(lm(orig.pcnm[,i]~spatial.predictors[,i])));
}
meta.pcnm = merge(meta.data,spatial.predictors,by="CuID"); head(meta.pcnm); dim(meta.pcnm); # merge pcnm vectors with meta data
rownames(meta.pcnm) = meta.pcnm$CuID;
meta.pcnm.for.vis = meta.pcnm;
meta.pcnm = meta.pcnm[,c("RingoldElev_ft","percent_mud_pred","NEAR_DIST_m","Core_Elevation_m",colnames(pcnm.out$vectors))]; head(meta.pcnm);
orig.meta.pcnm = read.csv("C:/Users/steg815/Desktop/Stegen_PNNL/IFRC_Spatial_Microbes/Ringold_meta.pcnm_Orig.csv",header=T,row.names=1); head(orig.meta.pcnm)
str(orig.meta.pcnm)
meta.pcnm = merge(meta.data,spatial.predictors,by="CuID"); head(meta.pcnm); dim(meta.pcnm); # merge pcnm vectors with meta data
rownames(meta.pcnm) = meta.pcnm$CuID;
meta.pcnm.for.vis = meta.pcnm;
meta.pcnm = meta.pcnm[,c("RingoldElev_ft","percent_mud_pred","NEAR_DIST_m","Core_Elevation_m",colnames(pcnm.out$vectors))]; head(meta.pcnm);
identical(orig.meta.pcnm,meta.pcnm)
for (i in 1:ncol(meta.pcnm)) {
plot(orig.meta.pcnm[,i],meta.pcnm[,i]); abline(0,1); print(summary(lm(orig.meta.pcnm[,i]~meta.pcnm[,i])));
}
meta.pca = princomp(meta.pcnm); rm('meta.pcnm');
summary(meta.pca);
loadings(meta.pca);
new.load = loadings(meta.pca);
meta.pca = princomp(orig.meta.pcnm);
orig.load = loadings(meta.pca);
identical(new.load,orig.load)
new.load
orig.load
rownames(meta.pcnm)
meta.pcnm = merge(meta.data,spatial.predictors,by="CuID"); head(meta.pcnm); dim(meta.pcnm); # merge pcnm vectors with meta data
rownames(meta.pcnm) = meta.pcnm$CuID;
meta.pcnm.for.vis = meta.pcnm;
meta.pcnm = meta.pcnm[,c("RingoldElev_ft","percent_mud_pred","NEAR_DIST_m","Core_Elevation_m",colnames(pcnm.out$vectors))]; head(meta.pcnm);
rownames(meta.pcnm)
cbind(rownames(meta.pcnm),rownames(orig.meta.pcnm))
str(meta.pcnm)
str(orig.meta.pcnm)
identical(meta.pcnm[,1],orig.meta.pcnm[,1])
identical(meta.pcnm[,2],orig.meta.pcnm[,2])
identical(meta.pcnm[,3],orig.meta.pcnm[,3])
identical(meta.pcnm[,4],orig.meta.pcnm[,4])
identical(meta.pcnm[,5],orig.meta.pcnm[,5])
identical(round(meta.pcnm[,5],digits=3),round(orig.meta.pcnm[,5],digits=3))
identical(round(meta.pcnm[,6],digits=3),round(orig.meta.pcnm[,6],digits=3))
identical(round(meta.pcnm[,7],digits=3),round(orig.meta.pcnm[,7],digits=3))
identical(round(meta.pcnm[,8],digits=3),round(orig.meta.pcnm[,8],digits=3))
identical(round(meta.pcnm[,9],digits=3),round(orig.meta.pcnm[,9],digits=3))
identical(round(meta.pcnm[,10],digits=3),round(orig.meta.pcnm[,10],digits=3))
identical(round(meta.pcnm[,11],digits=3),round(orig.meta.pcnm[,11],digits=3))
identical(round(meta.pcnm[,11],digits=3),round(orig.meta.pcnm[,11],digits=4))
identical(round(meta.pcnm[,11],digits=4),round(orig.meta.pcnm[,11],digits=4))
identical(round(meta.pcnm[,11],digits=5),round(orig.meta.pcnm[,11],digits=5))
identical(round(meta.pcnm[,11],digits=6),round(orig.meta.pcnm[,11],digits=6))
identical(round(meta.pcnm[,11],digits=7),round(orig.meta.pcnm[,11],digits=7))
identical(round(meta.pcnm[,11],digits=8),round(orig.meta.pcnm[,11],digits=8))
identical(round(meta.pcnm[,11],digits=9),round(orig.meta.pcnm[,11],digits=9))
identical(round(meta.pcnm[,11],digits=15),round(orig.meta.pcnm[,11],digits=15))
identical(round(meta.pcnm[,11],digits=14),round(orig.meta.pcnm[,11],digits=14))
round(meta.pcnm[,11],digits=15)
round(orig.meta.pcnm[,11],digits=15)
4^250
2^250
155*16
155*20
155*20
16*3*37
50*10
3100+1800
16*3
500/3
library(geiger)
105/15
100/15
100/15
1000/15
7*12
900/15
90-32
58/15
45+32
77/12
5*12
28/15
232/90
12*5
232/60
232/65
6*90
840-432
225/50
242/50
22*50
840-32
808-400
800/50
9*242
13*242
13*242+940
12*2*10*5
12*2*10*4.84
6*450
182-84
84*10
840+30
870-98
772-200
772-250
522/50
11*242
24*10*4.84
12*3*15
5*12*3
6*12*3
540-216
0.28*0.2
2.652 / 0.577
36*15
540/60
12*15 + 90 + 30*3
8*15 + 90 + 30*3
9*6
54*50
12*15
12*15 + 6*15
100*100
#!/usr/bin/env Rscript
#sim = commandArgs();
#sim = as.numeric(sim[length(sim)]);
# Choose number of time slices per simulation to analyze
num.of.time.slices = 1;
# Set minimum number of species in a clade needed to proceed with analysis
min.num.spp = 8;
Allen = 0;
partial.analysis = 1; # toggle to determine whether we're looking at all sims or just some
#New parameter for taking into account which of us is running this code
if(Allen==1) {
setwd('c:/documents and settings/hurlbert/species-energy-simulation')
Rlib.location = "C:/program files/R/R-2.15.2/library"
sim_dir = "C:/SENCoutput"
analysis_dir = "//bioark.bio.unc.edu/hurlbertallen/manuscripts/cladevscommunity/analyses"
} else {
setwd('C:/Users/steg815/Desktop/Stegen_PNNL/Spp-Energy-Niche-Conserv/species-energy-simulation')
sim_dir = "C:/Users/steg815/Desktop/Stegen_PNNL/Spp-Energy-Niche-Conserv/sims.out.130204" #wherever all of your zipped output files are
analysis_dir = "C:/Users/steg815/Desktop/Stegen_PNNL/Spp-Energy-Niche-Conserv/sims.out.130204" #wherever you want to store the results of these analyses
}
# Simulation workflow
#(2) load simulation and analysis functions
if (Allen==1){
library(ape,lib.loc=Rlib.location);
library(permute,lib.loc=Rlib.location);
library(nlme,lib.loc=Rlib.location);
library(vegan,lib.loc=Rlib.location);
library(picante,lib.loc=Rlib.location);
library(mvtnorm,lib.loc=Rlib.location);
library(caper,lib.loc=Rlib.location);
library(paleotree,lib.loc=Rlib.location);
library(plyr,lib.loc=Rlib.location);
library(phytools, lib.loc=Rlib.location);
library(foreach,lib.loc=Rlib.location);
library(doParallel,lib.loc=Rlib.location);
} else {
library(ape);
library(permute);
library(nlme);
library(vegan);
library(picante);
library(mvtnorm);
library(caper);
library(paleotree);
library(plyr);
library(phytools);
library(foreach);
library(doParallel);
}
#(3) read in master simulation matrix with chosen parameter combinations;
# then add fields for storing output summary
sim.matrix = as.data.frame(read.csv("SENC_Master_Simulation_Matrix.csv",header=T));
head(sim.matrix);
which.sims = sim.matrix$sim.id[sim.matrix$carry.cap == 'on' & sim.matrix$energy.gradient == 'on']; length(which.sims);
which.sims = sim.matrix$sim.id[sim.matrix$carry.cap == 'on' & sim.matrix$energy.gradient == 'on' & sim.matrix$sim.id > 3464]; length(which.sims);
tropical.sims = sim.matrix$sim.id[sim.matrix$reg.of.origin == 'tropical' sim.matrix$carry.cap == 'on' & sim.matrix$energy.gradient == 'on' & sim.matrix$sim.id > 3464]; length(which.sims);
tropical.sims = sim.matrix$sim.id[sim.matrix$reg.of.origin == 'tropical' & sim.matrix$carry.cap == 'on' & sim.matrix$energy.gradient == 'on' & sim.matrix$sim.id > 3464]; length(which.sims);
tropical.sims = sim.matrix$sim.id[sim.matrix$reg.of.origin == 'tropical' & sim.matrix$carry.cap == 'on' & sim.matrix$energy.gradient == 'on' & sim.matrix$sim.id > 3464]; length(tropical.sims);
temperate.sims = sim.matrix$sim.id[sim.matrix$reg.of.origin == 'temperate' & sim.matrix$carry.cap == 'on' & sim.matrix$energy.gradient == 'on' & sim.matrix$sim.id > 3464]; length(temperate.sims);
tropical.sims
temperate.sims
source('reg_calc_and_analysis.r');
source('make.phylo.jimmy.fun.r');
source('lat.grad.time.plot.r');
source('clade.origin.corr.plot.r');
source('clade.exmpl.figs.r');
source('extinct.calc.r');
source('unzipping_files.r');
sim = tropical.sims[1];
sim.results = output.unzip(sim_dir,sim)
all.populations = sim.results$all.populations
head(all.populations)
trop.orig.extreme = 3;
temp.orig.extreme = 8;
?apply
?tapply
tapply(all.populations$extant,all.populations$region,sum)
time.richness = sim.results$time.richness
head(time.richness)
min(time.richness$time[time.richness$region == trop.orig.extreme & time.richness$spp.rich >= 5])
trop.times = numeric();
for (i in 1:length(tropical.sims)) {
sim = tropical.sims[i];
sim.results = output.unzip(sim_dir,sim)
time.richness = sim.results$time.richness
trop.times = c(trop.times,min(time.richness$time[time.richness$region == trop.orig.extreme & time.richness$spp.rich >= 5]));
}
hist(trop.times); quantile(trop.times);
temp.times = numeric();
for (i in 1:length(temperate.sims)) {
sim = temperate.sims[i];
sim.results = output.unzip(sim_dir,sim)
time.richness = sim.results$time.richness
temp.times = c(temp.times,min(time.richness$time[time.richness$region == temp.orig.extreme & time.richness$spp.rich >= 5]));
print(i)
}
hist(temp.times); quantile(temp.times);
warnings()
i=1
sim = temperate.sims[i];
sim
sim.results = output.unzip(sim_dir,sim)
time.richness = sim.results$time.richness
temp.times = numeric();
min(time.richness$time[time.richness$region == temp.orig.extreme & time.richness$spp.rich >= 5])
time.richness$time[time.richness$region == temp.orig.extreme]
temp.orig.extreme
head(time.richness)
sim
temperate.sims
sim.results = output.unzip(sim_dir,sim)
time.richness = sim.results$time.richness
temp.times = c(temp.times,min(time.richness$time[time.richness$region == temp.orig.extreme & time.richness$spp.rich >= 5]));
print(i)
temp.times
temp.times = numeric();
for (i in 1:length(temperate.sims)) {
sim = temperate.sims[i];
sim.results = output.unzip(sim_dir,sim)
time.richness = sim.results$time.richness
temp.times = c(temp.times,min(time.richness$time[time.richness$region == temp.orig.extreme & time.richness$spp.rich >= 5]));
print(i)
}
hist(temp.times); quantile(temp.times);
